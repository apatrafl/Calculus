# Calculus
4 different methods of finding the roots of a function: bisector, Newton's, Secant Consecutive, and Secant Bounded

Bisection Method:
Bisection method uses a lower bound and upper bound to find the x-intercept of a given function. First, the program will ask the user which method they wish to solve their function. For the bisection method, the user should type in “bisection”. The user will then be prompted to enter in the lower bound and the upper bound, referred to as a and b. As for the function, the user will have to enter the function straight into the code in the 10th line. The error is set to the difference between a and b. The a and b will be averaged to create a third point. Then, if the product of the y values of a and b is greater than 0, an error message will display. If the product of the y values of a and c is less than 0, b is set equal to the third point. If the product of the y values of b and c is less than 0, a is set equal to the third point. This repeats until the difference between a and b is less than 0.0001. Finally, the root, c, will print. The bisection method will always work as long as the right domain is given to the function.

Newton Method:
Newton method uses the derivative of the given function to find its x-intercept. First, the function is run through the derivative function, which returns defunc. Then, if the derivative is equal to 0, an error message appears. Otherwise, over 1000 iterations, x is solved for and displayed at the end. An error may occur if dividing by 0.

Secant Bounded Method:
Secant method uses a lower guess and an upper guess to plug into the given function in order to find its x-intercept. First, the slope of the 2 points of the function using the slope formula. We set that equal to k. Then we use the slope to determine the new point, which we assign to x. If at x, its y value is greater than 0, then we set b equal to the new point, or x. If at x, its value is less than 0, we set a equal to x. After 1000 iterations, we display x, the root of the function.

Secant Consecutive Method:
Secant method uses a lower guess and an upper guess to plug into the given function in order to find its x-intercept, except we don’t take into account the y value of the new point. First, the slope of the 2 points of the function using the slope formula. We set that equal to k. Then we use the slope to determine the new point, which we assign to x. Then we switch the variable values, setting a equal to b and b equal to the new point, or x. After 1000 iterations, the program will display x, the root. However, if any time before the end of the 1000 iterations, the y value of the new point is about 0.001 away from 0, the program ends and displays x.

Evaluation:
On bisection method, it performed well with simple functions and narrow bounds.
However, when tested with bounds with multiple roots within, the program fails. Furthermore, as the function got more complex, it took longer to process. As cos(x) and sin(x) were introduced and the function got longer, so did the time it took to process. However, bisection was relatively accurate as long as the bounds were narrow. Newton’s method worked really well, despite curveballs. Not only was it relatively quick, but it handled complex functions and completely inaccurate guesses well. However, it does fail if the user inputs the inflection point, where the derivative is 0. There, the method does suffer, however the chances of this are miniscule. For secant bounded, while it’s efficient, increasing and decreasing the range changes the root it’ll find, so the user has to have a good idea of where the root may be. The same can be said for secant consecutive, where increasing the range will yield a different root depending on the bounds. The secant methods took a regular amount of time, despite complex functions.
